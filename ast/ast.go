// Package ast defines the AST grammar for BJK files.
// See: https://github.com/setzer22/blackjack
package ast

import (
	"strconv"
	"strings"

	"github.com/alecthomas/participle/v2"
	"github.com/alecthomas/participle/v2/lexer"
	lua "github.com/yuin/gopher-lua"
)

const headerStr = "// BLACKJACK_VERSION_HEADER"

// Lexer represents a lexer for the BJK grammar.
var Lexer = lexer.MustSimple([]lexer.SimpleRule{
	{"Header", `(?:` + headerStr + `)[ ]*`},
	{"Ident", `[a-zA-Z]\w*`},
	{"Float", `\-?(?:\d*)?\.\d+`},
	{"Int", `\-?(?:\d*)?\d+`},
	{"String", `\"[^\"]*\"`},
	{"Punct", `[-[!@#$%^&*()+_={}\|:;"'<,>.?/]|]`},
	{"Whitespace", `[ \t\n\r]+`},
})

// Parser represents a participle parser for the BJK grammar.
var Parser = participle.MustBuild[BJK](
	participle.Lexer(Lexer),
	participle.Elide("Whitespace"),
	// We cannot use Unquote when parsing Rust-generated strings because
	// it quotes them incorrectly. For example: "reconcil\'d"
	// participle.Unquote("String"),
	rustUnquoteOption("String"),
)

func rustUnquoteOption(types ...string) participle.Option {
	if len(types) == 0 {
		types = []string{"String"}
	}
	return participle.Map(func(t lexer.Token) (lexer.Token, error) {
		value, err := rustUnquote(t.Value)
		if err != nil {
			t.Value = strings.Replace(t.Value, `\'`, "'", -1)
			value, err = rustUnquote(t.Value)
			if err != nil {
				return t, participle.Errorf(t.Pos, "invalid quoted string '%v': %s", t.Value, err.Error())
			}
		}
		t.Value = value
		return t, nil
	}, types...)
}

func rustUnquote(s string) (string, error) {
	quote := s[0]
	s = s[1 : len(s)-1]
	out := ""
	for s != "" {
		value, _, tail, err := strconv.UnquoteChar(s, quote)
		if err != nil {
			return "", err
		}
		s = tail
		out += string(value)
	}
	return out, nil
}

// New returns a new BJK ast, ready to be populated.
func New() *BJK {
	return &BJK{
		Version: Version{Minor: 1},
		Graph: &Graph{
			UIData: &UIData{
				Zoom: 1,
			},
		},
	}
}

// BJK is the root of a Blackjack file.
type BJK struct {
	Version Version `Header @@`

	Graph *Graph `"(" @@* ")"`
}

// Graph represents the content of the Blackjack file.
type Graph struct {
	Nodes []*Node `"nodes" ":" "[" ( "(" @@* ")" ","? )* "]" ","?`

	DefaultNode *uint64 `( "default_node" ":" ( "Some" "(" @Int ")" | "None" ) ","? )?`

	UIData *UIData `( "ui_data" ":" ( "Some" "(" @@ ")" | "None" ) ","? )?`

	ExternalParameters *ExternalParameters `( "external_parameters" ":"  ( "Some" "(" @@ ")" | "None" ) ","? )?`
}

// Version represents the version of the Blackjack file.
type Version struct {
	Major int `@Int`
	Minor int `@Int`
	Patch int `@Int`
}

// Node represents a node in Blackjack.
type Node struct {
	OpName      string    `"op_name" ":" @String ","?` // e.g. "MakeScalar"
	ReturnValue *string   `"return_value" ":" ( "Some" "(" @String ")" | "None" ) ","?`
	Inputs      []*Input  `"inputs" ":" "[" ( "(" @@* ")" ","? )* "]" ","?`
	Outputs     []*Output `"outputs" ":" "[" ( "(" @@* ")" ","? )* "]" ","?`

	// Label is not preserved in the BJK file.
	Label string // e.g. "Scalar"
	// Index is not preserved in the BJK file.
	Index uint64
	// NodePosition, if set, is used to manually position the node.
	NodePosition *Vec2

	// EvalOutputs are generated by Eval but not preserved in the BJK file.
	EvalOutputs map[string]lua.LValue
}

// GetInput returns a named input or `nil, false` if not found.
func (n *Node) GetInput(name string) (*Input, bool) {
	for _, input := range n.Inputs {
		if input.Name == name {
			return input, true
		}
	}
	return nil, false
}

// GetInputs returns a slice of input names.
func (n *Node) GetInputs() []string {
	names := make([]string, 0, len(n.Inputs))
	for _, input := range n.Inputs {
		names = append(names, input.Name)
	}
	return names
}

// GetOutput returns a named output or `nil, false` if not found.
func (n *Node) GetOutput(name string) (*Output, bool) {
	for _, output := range n.Outputs {
		if output.Name == name {
			return output, true
		}
	}
	return nil, false
}

// GetOutputs returns a slice of output names.
func (n *Node) GetOutputs() []string {
	names := make([]string, 0, len(n.Outputs))
	for _, output := range n.Outputs {
		names = append(names, output.Name)
	}
	return names
}

// Input represents a node's input.
type Input struct {
	Name     string         `"name" ":" @String ","*`
	DataType string         `"data_type" ":" @String ","*`
	Kind     DependencyKind `"kind" ":" @@ ","*`

	// Props are not preserved in the BJK file.
	Props map[string]lua.LValue
}

// DependencyKind is an enum that represents an input's dependency.
// It is either an External or a Connection, but not both.
type DependencyKind struct {
	External   *External   `  "External" "(" @@* ")" ","?`
	Connection *Connection `| "Conection" "(" @@* ")" ","?`
}

// External represents an external dependency kind.
type External struct {
	Promoted *string `"promoted" ":" ( "Some" "(" @String ")" | "None" ) ","?`
}

// Connection represents a DependencyKind's connection.
type Connection struct {
	NodeIdx   uint64 `"node_idx" ":" @Int ","?`
	ParamName string `"param_name" ":" @String ","?`
}

// Output represents a node's output.
type Output struct {
	Name     string `"name" ":" @String ","*`
	DataType string `"data_type" ":" @String ","*`
}

// UIData represents data to drive the user interface.
type UIData struct {
	NodePositions    []*Vec2  `"(" "node_positions" ":" "[" @@* "]" ","?`
	NodeOrder        []uint64 `"node_order" ":" "[" ( @Int ","? )* "]" ","?`
	Pan              Vec2     `"pan" ":" @@ ","?`
	Zoom             float64  `"zoom" ":" @Float ","?`
	LockedGizmoNodes []uint64 `"locked_gizmo_nodes" ":" "["  ( @Int ","? )* "]" ","? ")" ","?`
}

// Vec2 represents a 2D vector (or point).
type Vec2 struct {
	X float64 `"(" @Float ","`
	Y float64 `@Float ")" ","?`
}

// ExternalParameters represents external parameters.
type ExternalParameters struct {
	ParamValues []*ParamValue `"(" "param_values" ":" "{" @@* "}" ","? ")" ","?`
}

// ParamValue is an enum that represents a parameter value.
// It is exactly one of the values.
type ParamValue struct {
	NodeIdx   uint64 `"(" "node_idx" ":" @Int ","?`
	ParamName string `"param_name" ":" @String ","? ")" ":"`

	ValueEnum ValueEnum `@@`
}

// ValueEnum represents an enum for a ParamValue.
type ValueEnum struct {
	Scalar    *ScalarValue    `  @@`
	Selection *SelectionValue `| @@`
	StrVal    *StringValue    `| @@`
	Vector    *VectorValue    `| @@`
}

// VectorValue is one type of ParamValue.
type VectorValue struct {
	X float64 `"Vector" "(" "(" @Float ","`
	Y float64 `@Float ","`
	Z float64 `@Float ")" ")" ","?`
}

// ScalarValue is one type of ParamValue.
type ScalarValue struct {
	X float64 `"Scalar" "(" @Float ")" ","?`
}

// StringValue is one type of ParamValue.
type StringValue struct {
	S string `"String" "(" @String ")" ","?`
}

// SelectionValue is one type of ParamValue.
type SelectionValue struct {
	Selection string `"String" "(" @String ")" ","?`
}
